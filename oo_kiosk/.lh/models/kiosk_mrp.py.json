{
    "sourceFile": "models/kiosk_mrp.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1658448213127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1658448239951,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,11 +29,10 @@\n \n     @api.model\n     def create(self, vals):\n         if vals.get('name') == 'New':\n-            vals['name'] = self.env['ir.sequence'].next_by_code(\n-                    'purchase.import.sequence') or _('New')\n-            res = super().create(vals)\n+            vals['name'] = self.env['ir.sequence'].next_by_code('kiosk.order.sequence') or _('New')\n+        res = super().create(vals)\n         return res\n \n     @api.depends('mrp_ids')\n     def _compute_mrp_count(self):\n"
                },
                {
                    "date": 1658448460609,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,9 +17,9 @@\n \n class KioskManufacturing(models.Model):\n     _name = 'kiosk.mrp'\n \n-    name = fields.Char(string='Name', default='New')\n+    name = fields.Char(string='Name', default='New', readonly=\"1\")\n     group_id = fields.Many2one('kiosk.group', string='Product Group')\n     date_planned = fields.Datetime('Date Planned', default=datetime.now())\n     mrp_type = fields.Selection(string='Type', selection=[('kiosk', 'Kiosk'), ('program', 'Program')], required=True)\n     state = fields.Selection(string='Status', selection=[(\n"
                }
            ],
            "date": 1658448213127,
            "name": "Commit-0",
            "content": "# -*- coding: utf-8 -*-\n\nfrom datetime import datetime\n\nfrom odoo import _, api, fields, models\nfrom odoo.exceptions import ValidationError\n\n\nclass Mrp(models.Model):\n    _inherit = 'mrp.production'\n\n    kiosk_mrp_id = fields.Many2one('kiosk.mrp', string='Kiosk Mrp')\n\n    # def action_confirm(self):\n    #     raise ValidationError(self.move_finished_ids)\n\n\nclass KioskManufacturing(models.Model):\n    _name = 'kiosk.mrp'\n\n    name = fields.Char(string='Name', default='New')\n    group_id = fields.Many2one('kiosk.group', string='Product Group')\n    date_planned = fields.Datetime('Date Planned', default=datetime.now())\n    mrp_type = fields.Selection(string='Type', selection=[('kiosk', 'Kiosk'), ('program', 'Program')], required=True)\n    state = fields.Selection(string='Status', selection=[(\n        'draft', 'Draft'), ('posted', 'Posted'), ('cancel', 'Cancelled')], default='draft')\n    mrp_ids = fields.Many2many(comodel_name='mrp.production', string='Mrp Orders')\n    mrp_count = fields.Integer(string='Manufacturing Orders Count', compute='_compute_mrp_count')\n\n    @api.model\n    def create(self, vals):\n        if vals.get('name') == 'New':\n            vals['name'] = self.env['ir.sequence'].next_by_code(\n                    'purchase.import.sequence') or _('New')\n            res = super().create(vals)\n        return res\n\n    @api.depends('mrp_ids')\n    def _compute_mrp_count(self):\n        for rec in self:\n            rec.mrp_count = len(rec.mrp_ids)\n\n    def get_mrps(self):\n        return {\n            'type': 'ir.actions.act_window',\n            'name': f'{self.group_id.name} Mrp Orders',\n            'res_model': 'mrp.production',\n            'view_mode': 'tree,form',\n            'domain': [('kiosk_mrp_id', '=', self.id)]\n        }\n\n    def _get_default_locations(self):\n        company_id = self.env.context.get('default_coompay_id', self.env.company.id)\n        picking_type = self.env['stock.picking.type'].search(\n            [('code', '=', 'mrp_operation'), ('warehouse_id.company_id', '=', company_id)])\n        src_location = picking_type.default_location_src_id\n        dest_location = picking_type.default_location_dest_id\n        return src_location, dest_location\n\n    def action_confirm(self):\n        # TODO: when creating a mo in the same group, they should share the same picking. Use procurement_group to achieve this.\n        # group_vals = []\n        src_location_id, dest_location_id = self._get_default_locations()\n        kiosk_lines = self.env['kiosk.group'].search([]).filtered(lambda k: k.package_lines).mapped('package_lines')\n        procurement_group_id = False\n        mrp_ids = []\n        for line in kiosk_lines:\n            vals = {\n                'date_planned_start': self.date_planned,\n                'product_id': line.bom_id.product_id.id,\n                'product_uom_id': line.bom_id.product_id.uom_id.id,\n                'bom_id': line.bom_id.id,\n                'product_qty': 1,\n                'kiosk_mrp_id': self.id,\n                'location_src_id': src_location_id.id,\n                'location_dest_id': dest_location_id.id,\n                'procurement_group_id': procurement_group_id\n            }\n            # group_vals.append(vals)\n            mo = self.env['mrp.production'].with_context({'import_file': True}).create(vals)\n            mo._create_workorder()\n            # procurement_group_id = mo.procurement_group_id.id\n            mrp_ids.append(mo.id)\n        self.write({\n            'mrp_ids': [(6, 0, mrp_ids)],\n            'state': 'posted'\n        })\n\n        # for mo in mos:\n        #     # mo._onchange_product_id()\n        #     # mo._onchange_bom_id()\n        #     # mo._onchange_move_raw()\n        #     mo._create_workorder()\n        #     # mo._create_update_move_finished()\n\n    def action_cancel(self):\n        self.write({'state': 'cancel'})\n        self.mrp_ids.action_cancel()\n"
        }
    ]
}